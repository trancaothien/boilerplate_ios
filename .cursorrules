# BoilerplateIOS - Cursor Rules

## Project Architecture

This iOS project follows **MVVM-C (Model-View-ViewModel-Coordinator)** architecture pattern with Tuist for project generation.

### Directory Structure

```
BoilerplateIOS/
├── Sources/
│   ├── Coordinator/          # App-level coordinators
│   │   ├── AppCoordinator.swift
│   │   └── [Feature]Coordinator.swift
│   └── Views/
│       └── [Feature]/
│           ├── [Feature]View.swift
│           └── [Feature]ViewModel.swift
├── Resources/
│   ├── Assets.xcassets/
│   └── Firebase/
└── Tests/

Modules/
├── Core/                     # Core framework (shared utilities)
│   └── Sources/
│       ├── Base/            # Base classes (BaseViewModel, etc.)
│       ├── Coordinator/     # Coordinator protocol
│       ├── Constants/       # App constants, Environment
│       ├── Extensions/      # Swift extensions
│       └── Utilities/       # Helper classes
└── Networking/              # Networking framework
    └── Sources/
```

---

## Coordinator Pattern Rules

### 1. Creating a New Coordinator

When creating a new coordinator, follow this template:

```swift
import UIKit
import SwiftUI
import Core

/// [Feature] Coordinator manages [feature description] flow
final class [Feature]Coordinator: Coordinator {
    var navigationController: UINavigationController
    var childCoordinators: [Coordinator] = []
    
    private weak var parentCoordinator: [Parent]Coordinator?
    
    init(navigationController: UINavigationController, parentCoordinator: [Parent]Coordinator?) {
        self.navigationController = navigationController
        self.parentCoordinator = parentCoordinator
    }
    
    func start() {
        let viewModel = [Feature]ViewModel()
        viewModel.coordinator = self
        let view = [Feature]View(viewModel: viewModel)
        
        // Choose navigation action:
        // push(view)           - Push onto navigation stack
        // replaceAll(with: view) - Set as root view
        // present(view)        - Present modally
    }
    
    func finish() {
        parentCoordinator?.removeChildCoordinator(self)
    }
    
    // MARK: - Navigation Methods
    
    func showNextScreen() {
        // Navigate to next screen
    }
    
    func goBack() {
        pop()
    }
}
```

### 2. Coordinator Hierarchy

- **AppCoordinator**: Root coordinator, manages the main app flow
- **Feature Coordinators**: Child coordinators for specific features
- Always maintain parent-child relationships
- Use `weak` reference for parent coordinator to avoid retain cycles

### 3. Navigation Methods (from Coordinator protocol)

```swift
// Push navigation
push(viewController)              // Push UIViewController
push(swiftUIView)                 // Push SwiftUI View

// Pop navigation  
pop()                             // Pop current view
popToRoot()                       // Pop to root view
popTo(SomeViewController.self)    // Pop to specific type

// Replace navigation
replace(with: viewController)     // Replace top view
replaceAll(with: viewController)  // Set as new root

// Modal presentation
present(viewController)                          // Default modal
present(view, configuration: .fullScreen)        // Full screen
present(view, configuration: .pageSheet)         // Page sheet
presentNavigation(rootViewController: vc)        // Modal with nav

// Dismiss
dismiss()                         // Dismiss modal
dismissToRoot()                   // Dismiss all modals
```

### 4. Child Coordinator Management

```swift
// Add child coordinator
let childCoordinator = FeatureCoordinator(
    navigationController: navigationController,
    parentCoordinator: self
)
addChildCoordinator(childCoordinator)
childCoordinator.start()

// Remove when done
removeChildCoordinator(childCoordinator)
```

---

## Screen/Module Creation Rules

### 1. Creating a New Screen

When creating a new screen, always create these files:

1. **View** (`[Feature]View.swift`)
2. **ViewModel** (`[Feature]ViewModel.swift`)
3. **Coordinator** (`[Feature]Coordinator.swift`) - if it's a new flow

### 2. View Template (SwiftUI)

```swift
import SwiftUI
import Core

struct [Feature]View: View {
    @ObservedObject var viewModel: [Feature]ViewModel
    
    init(viewModel: [Feature]ViewModel) {
        self.viewModel = viewModel
    }
    
    var body: some View {
        ZStack {
            // Background
            Color(.systemGroupedBackground)
                .ignoresSafeArea()
            
            // Content
            ScrollView {
                VStack(spacing: 16) {
                    // Your content here
                }
                .padding()
            }
        }
        .navigationTitle("[Feature]")
        .navigationBarTitleDisplayMode(.large)
        .loading(viewModel.isLoading)
        .errorAlert(errorMessage: $viewModel.errorMessage)
    }
}

#Preview {
    [Feature]View(viewModel: [Feature]ViewModel())
}
```

### 3. ViewModel Template

```swift
import Foundation
import Core
import Combine

final class [Feature]ViewModel: BaseViewModel {
    // MARK: - Published Properties
    @Published var data: [DataType] = []
    
    // MARK: - Coordinator
    weak var coordinator: [Feature]Coordinator?
    
    // MARK: - Setup
    override func setupBindings() {
        loadData()
    }
    
    // MARK: - Data Loading
    func loadData() {
        setLoading(true)
        
        // API call here
        // Use handleError(_:) for errors
        // Use setLoading(false) when complete
    }
    
    func refresh() {
        loadData()
    }
    
    // MARK: - Navigation Actions
    
    func navigateToDetail(item: DataType) {
        coordinator?.showDetail(for: item)
    }
    
    func goBack() {
        coordinator?.goBack()
    }
}
```

### 4. ViewModel Rules

- Always extend `BaseViewModel` from Core module
- Use `@Published` for reactive properties
- Keep weak reference to coordinator: `weak var coordinator: [Feature]Coordinator?`
- Navigation actions should call coordinator methods
- Use `setLoading(_:)` and `handleError(_:)` from BaseViewModel

---

## Module Creation Rules

### 1. Core Module

Location: `Modules/Core/Sources/`

Used for:
- Base classes (BaseViewModel, BaseViewController)
- Protocols (Coordinator)
- Extensions
- Utilities (Logger, KeychainHelper)
- Constants and Environment configuration

### 2. Networking Module

Location: `Modules/Networking/Sources/`

Used for:
- API Service
- Endpoints
- Request/Response models
- Network errors

### 3. Creating a New Feature Module

If you need to create a new reusable module:

1. Create folder structure: `Modules/[ModuleName]/Sources/`
2. Add to `Project.swift`:

```swift
let newModuleTarget: Target = .target(
    name: "[ModuleName]",
    destinations: [.iPhone, .iPad],
    product: .framework,
    bundleId: "dev.tuist.[modulename]",
    deploymentTargets: .iOS("15.0"),
    infoPlist: .default,
    buildableFolders: [
        "Modules/[ModuleName]/Sources",
    ],
    dependencies: [
        // Add dependencies here
    ],
    settings: .settings(
        base: [
            "DEFINES_MODULE": "YES",
            "PRODUCT_MODULE_NAME": "[ModuleName]",
            "CLANG_ENABLE_MODULES": "YES",
        ],
        configurations: configurations
    )
)
```

3. Add to targets array in Project.swift
4. Run `make generate` to regenerate project

---

## Environment Configuration Rules

### 1. Environments Available

- **Develop**: Development environment
- **Staging**: Internal testing
- **Sandbox**: Pre-production testing
- **Production**: Live environment

### 2. Using Environment in Code

```swift
import Core

// Check current environment
let env = Environment.current

if env == .develop {
    // Development only code
}

// Get configuration values
let config = AppConfiguration.shared
print(config.apiBaseURL)
print(config.isDebug)
print(config.shouldEnableLogging)

// Conditional compilation
#if DEVELOP
    // Development only
#elseif PRODUCTION
    // Production only
#endif
```

### 3. XCConfig Values

Access values from xcconfig files via Info.plist:
- `API_BASE_URL`
- `ENVIRONMENT`
- `APP_NAME`

---

## Code Style Guidelines

### 1. File Organization

```swift
import UIKit
import SwiftUI
import Core

// MARK: - Protocol/Delegate

protocol SomeDelegate: AnyObject {
    func didSomething()
}

// MARK: - Main Type

final class SomeClass {
    
    // MARK: - Properties
    
    private let dependency: Dependency
    
    // MARK: - Initialization
    
    init(dependency: Dependency) {
        self.dependency = dependency
    }
    
    // MARK: - Public Methods
    
    func publicMethod() { }
    
    // MARK: - Private Methods
    
    private func privateMethod() { }
}

// MARK: - Extensions

extension SomeClass: SomeProtocol {
    func protocolMethod() { }
}
```

### 2. Naming Conventions

- **Coordinators**: `[Feature]Coordinator` (e.g., `HomeCoordinator`, `LoginCoordinator`)
- **Views**: `[Feature]View` (e.g., `HomeView`, `ProfileView`)
- **ViewModels**: `[Feature]ViewModel` (e.g., `HomeViewModel`, `ProfileViewModel`)
- **Protocols**: Descriptive names with `-able`, `-ing`, or `-Delegate` suffix

### 3. Access Control

- Use `private` by default
- Use `internal` (default) for same-module access
- Use `public` only when exposing to other modules
- Use `final` for classes that shouldn't be subclassed

---

## Common Tasks

### Adding a New Screen

1. Create `Views/[Feature]/[Feature]View.swift`
2. Create `Views/[Feature]/[Feature]ViewModel.swift`
3. Create `Coordinator/[Feature]Coordinator.swift` (if new flow)
4. Add navigation method in parent coordinator
5. Run `make generate`

### Adding a New API Endpoint

1. Create endpoint in `Modules/Networking/Sources/[Feature]Endpoint.swift`
2. Follow `APIEndpoint` protocol
3. Add response model if needed
4. Use `APIService` to make requests

### Adding a New Utility

1. Add to `Modules/Core/Sources/Utilities/`
2. Make it `public` to expose to app target
3. Run `make generate`

---

## Commands Reference

```bash
make setup          # First time setup
make generate       # Regenerate Xcode project
make reset          # Clean everything and regenerate
make build-dev      # Build Develop scheme
make build-prod     # Build Production scheme
make test           # Run unit tests
make open           # Open in Xcode
make help           # Show all commands
```

